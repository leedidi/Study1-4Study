SELECT USER
FROM DUAL;
--==>> SCOTT


--@ 같이풀거 X고, 30분 줄 거 ! ~ 9시 42분까지
--@ 팀원들과 쉐어
--@ 15분 후 다시 확인! ~ 10시 18분?
--@ 시범시행시에는 PLSQL 페이지 벗어나서 걍 SCOTT에서 하는게나을듯!!


--○ TBL_입고 테이블에서 입고수량을 수정(변경)하는 프로시저를 작성한다.
--   프로시저 명 : PRC_입고_UPDATE(입고번호, 변경할입고수량);
--@ 입고수량이 변경되며 재고가 - 되면 안된다... 어디까지 제한해야 하는지 생각

-- 데이터 작성 시 신경써야 하는 부분
-- 0. 입고수량이 변경되며 재고가 -가 되면 안 됨
-- 0-1) 변경전재고수량 - 변경전입고수량 + 변경후입고수량 < 0 이면 예외처리

-- 1. TBL_입고 테이블에서 입고수량 수정(UPDATE) 
-- 2. TBL_상품 테이블에서 재고수량 수정(UPDATE) 
-- 2-1) 입력받은 입고번호에서 상품코드 얻어와서 해당 테이블에서 진행...
-- 2-2) 변경후재고수량 : 변경전재고수량 - 변경전입고수량 + 변경후입고수량

CREATE OR REPLACE PROCEDURE PRC_입고_UPDATE
( V_입고번호        IN TBL_입고.입고번호%TYPE
, V_변경후입고수량  IN TBL_입고.입고수량%TYPE
) 
IS
    -- 변경전입고수량
    V_변경전입고수량  TBL_입고.입고수량%TYPE;   
    -- 상품코드
    V_상품코드        TBL_상품.상품코드%TYPE;
    -- 변경전재고수량
    V_변경전재고수량  TBL_상품.재고수량%TYPE;
    --사용자 정의 예외 추가선언
    USER_DEFINE_ERROR EXCEPTION;
    
BEGIN
    -- V_상품코드, V_변경전입고수량 값 얻어오기
    SELECT 상품코드, 입고수량 INTO V_상품코드, V_변경전입고수량
    FROM TBL_입고
    WHERE 입고번호 = V_입고번호;
    
    -- V_변경전재고수량 값 얻어오기
    SELECT 재고수량 INTO V_변경전재고수량
    FROM TBL_상품
    WHERE 상품코드 = V_상품코드;
    
    -- 0. 입고수량이 변경되며 재고가 -가 되면 안 됨
    -- 0-1) 변경전재고수량 - 변경전입고수량 + 변경후입고수량 < 0 이면 예외처리
    IF (V_변경전재고수량 - V_변경전입고수량 + V_변경후입고수량 < 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    
    -- 1. TBL_입고 테이블에서 입고수량 수정(UPDATE) 
    UPDATE TBL_입고
    SET 입고수량 = V_변경후입고수량
    WHERE 입고번호 = V_입고번호;

    -- 2. TBL_상품 테이블에서 재고수량 수정(UPDATE) 
    -- 2-1) 입력받은 입고번호에서 상품코드 얻어와서 해당 테이블에서 진행...
    -- 2-2) 변경후재고수량 : 변경전재고수량 - 변경전입고수량 + 변경후입고수량
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 - V_변경전입고수량 + V_변경후입고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR 
            THEN RAISE_APPLICATION_ERROR(-20002, '재고 부족~!!!');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_입고_UPDATE이(가) 컴파일되었습니다.


--○ TBL_출고 테이블에서 출고수량을 삭제하는 프로시저를 작성한다.
--   프로시저 명 : PRC_출고_DELETE(출고번호);
--@ 입고 INSERT처럼.. 크게 신경쓸거X

-- 데이터 작성 시 신경써야 하는 부분
-- 1. TBL_출고 테이블에서 출고수량 삭제(DELETE) 
-- DELETE는 행전체...? 출고수량을 0으로 만들어야 하나
-- 2. TBL_상품 테이블에서 재고수량 수정(UPDATE)
-- 변경후재고수량 : 변경전재고수량 + 수정전출고수량

CREATE OR REPLACE PROCEDURE PRC_출고_DELETE
(V_출고번호 IN TBL_출고.출고번호%TYPE)
IS
    -- 상품코드 변수 추가 선언
    V_상품코드     TBL_상품.상품코드%TYPE;
    -- 수정전출고수량 변수 추가 선언
    V_수정전출고수량 TBL_출고.출고수량%TYPE;
    
BEGIN
    -- 상품코드, 수정전출고수량 값 얻어오기
    SELECT 상품코드, 출고수량 INTO V_상품코드, V_수정전출고수량
    FROM TBL_출고
    WHERE 출고번호 = V_출고번호;

    -- 1. TBL_출고 테이블에서 출고수량 삭제(DELETE)
    
    --DELETE 출고수량
    --DELETE -- 행 전체 삭제...., TRUNCATE? 아직안배운거같은데,, 아 그냥 행전체를 삭제하면 됨...ㅋㅋㅋ
    --FROM TBL_출고
    --WHERE 출고번호 = V_출고번호;
    DELETE
    FROM TBL_출고
    WHERE 출고번호 = V_출고번호;
    
    -- 2. TBL_상품 테이블에서 재고수량 수정(UPDATE)
    -- 변경후재고수량 : 변경전재고수량 + 수정전출고수량
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 + V_수정전출고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 예외 처리(WHEN OTHERS)
    EXCEPTION
    WHEN OTHERS THEN ROLLBACK;
    
    --커밋
    COMMIT;
    
END;
--==>> Procedure PRC_출고_DELETE이(가) 컴파일되었습니다.


--○ TBL_입고 테이블에서 입고수량을 삭제하는 프로시저를 작성한다.
--   프로시저 명 : PRC_입고_DELETE(입고번호);
--@ 고민해야함... 입고수량 건드리면 재고가 - 될수 있음... 

-- 데이터 작성 시 신경써야 하는 부분
--0. 변경전재고수량 - 삭제전입고수량 < 0 이라면 예외처리 발생!
--1. TBL_입고 테이블에서 입고수량 삭제(DELETE)
--2. TBL_상품 테이블에서 재고수량 수정
--2-1) 입력입고번호 받아와서 해당 입고번호에 해당하는 상품코드 받아와서 사용
--2-2) 변경후재고수량 : 변경전재고수량 - 삭제전입고수량

CREATE OR REPLACE PROCEDURE PRC_입고_DELETE
(V_입고번호 IN TBL_입고.입고번호%TYPE)
IS
    -- 삭제전입고수량 변수 추가 선언
    V_삭제전입고수량   TBL_입고.입고수량%TYPE;
    -- 상품코드 변수 추가 선언
    V_상품코드         TBL_상품.상품코드%TYPE;
    -- 변경전재고수량 변수 추가 선언
    V_변경전재고수량   TBL_상품.재고수량%TYPE;
    
    USER_DEFINE_ERROR   EXCEPTION;
    
BEGIN
    -- 삭제전입고수량, 상품코드 값 얻어오기
    SELECT 입고수량, 상품코드 INTO V_삭제전입고수량, V_상품코드
    FROM TBL_입고
    WHERE 입고번호 = V_입고번호;
    
    -- 변경전재고수량 값 얻어오기
    SELECT 재고수량 INTO V_변경전재고수량
    FROM TBL_상품
    WHERE 상품코드 = V_상품코드;
    
    --0. 변경전재고수량 - 삭제전입고수량 < 0 이라면 예외처리 발생!
    IF(V_변경전재고수량 - V_삭제전입고수량 < 0)
        THEN RAISE USER_DEFINE_ERROR;
    END IF;
    
    --1. TBL_입고 테이블에서 입고수량 삭제(DELETE)
    DELETE
    FROM TBL_입고
    WHERE 입고번호 = V_입고번호;
    
    --2. TBL_상품 테이블에서 재고수량 수정
    --2-1) 입력입고번호 받아와서 해당 입고번호에 해당하는 상품코드 받아와서 사용
    --2-2) 변경후재고수량 : 변경전재고수량 - 삭제전입고수량
    UPDATE TBL_상품
    SET 재고수량 = 재고수량 - V_삭제전입고수량
    WHERE 상품코드 = V_상품코드;
    
    -- 커밋
    COMMIT;
    
    -- 예외 처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20002, '재고 부족~!!!');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;
END;
--==>> Procedure PRC_입고_DELETE이(가) 컴파일되었습니다.


--------------------------------------------------------------------------------

--■■■ CURSOR(커서) ■■■--

-- 1. 오라클에서 하나의 레코드가 아닌 여러 레코드로 구성된 작업 영역에서
--    SQL 문을 실행하고 그 과정에서 발생한 정보를 저장하기 위하여
--    커서(CURSOR)를 사용하며, 커서에는 암시적 커서와 명시적 커서가 있다.
--@ 말하지 않아도 작동되는 암시적 커서, 말 해야 작동되는 명시적 커서

-- 2. 암시적 커서는 모든 SQL 문에 존재하며,
--    SQL 문 실행 후 오직 하나의 행(ROW)만 출력하게 된다.
--    그러나 SQL 문을 실행한 결과물(RESULT SET)이
--    여러 행(ROW)으로 구성된 경우
--    커서(CURSOR)를 명시적으로 선언해야 여러 행(ROW)을 다룰 수 있다.

--@ 커서는 뭘 담아내는 구조... (LIKE 깜짝 선물상자)
--@ 꾹 누른상태에서 뚜껑 닫아놓으면 그냥 상자
--@ 뚜껑 여는 순간 안의 데이터들이 한번에 왂! 튀어나옴


SET SERVEROUTPUT ON;
--==>> 작업이 완료되었습니다.

--○ 커서 이용 전 상황(단일 행 접근 시)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
BEGIN
    SELECT NAME, TEL INTO V_NAME, V_TEL
    FROM TBL_INSA
    WHERE NUM=1001;
    
    DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
END;
--==>> 홍길동, 011-2356-4528
-- 다시 확인하기 -> 확인 완료!

--○ 커서 이용 전 상황(다중행 접근 시)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
BEGIN
    SELECT NAME, TEL INTO V_NAME, V_TEL
    FROM TBL_INSA;

    DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
END;
--==>> 에러 발생
-- 다시 확인하기 -> 확인 완료
/*
ORA-01422: exact fetch returns more than requested number of rows
*/

--○ 커서 이용 전 상황(다중 행 접근 시 - 반복문 활용)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
    
    V_NUM   TBL_INSA.NUM%TYPE := 1001;
BEGIN
    
    LOOP
        SELECT NAME, TEL INTO V_NAME, V_TEL
        FROM TBL_INSA
        WHERE NUM=V_NUM;
        
        DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
        
        EXIT WHEN V_NUM >= 1062;
        
        V_NUM := V_NUM +1;
        
    END LOOP;
    
END;
--==>>
/*
홍길동, 011-2356-4528
이순신, 010-4758-6532
이순애, 010-4231-1236
김정훈, 019-5236-4221
한석봉, 018-5211-3542
이기자, 010-3214-5357
장인철, 011-2345-2525
김영년, 016-2222-4444
나윤균, 019-1111-2222
김종서, 011-3214-5555
유관순, 010-8888-4422
정한국, 018-2222-4242
조미숙, 019-6666-4444
황진이, 010-3214-5467
이현숙, 016-2548-3365
이상헌, 010-4526-1234
엄용수, 010-3254-2542
이성길, 018-1333-3333
박문수, 017-4747-4848
유영희, 011-9595-8585
홍길남, 011-9999-7575
이영숙, 017-5214-5282
김인수, 
김말자, 011-5248-7789
우재옥, 010-4563-2587
김숙남, 010-2112-5225
김영길, 019-8523-1478
이남신, 016-1818-4848
김말숙, 016-3535-3636
정정해, 019-6564-6752
지재환, 019-5552-7511
심심해, 016-8888-7474
김미나, 011-2444-4444
이정석, 011-3697-7412
정영희, 
이재영, 011-9999-9999
최석규, 011-7777-7777
손인수, 010-6542-7412
고순정, 010-2587-7895
박세열, 016-4444-7777
문길수, 016-4444-5555
채정희, 011-5125-5511
양미옥, 016-8548-6547
지수환, 011-5555-7548
홍원신, 011-7777-7777
허경운, 017-3333-3333
산마루, 018-0505-0505
이기상, 
이미성, 010-6654-8854
이미인, 011-8585-5252
권영미, 011-5555-7548
권옥경, 010-3644-5577
김싱식, 011-7585-7474
정상호, 016-1919-4242
정한나, 016-2424-4242
전용재, 010-7549-8654
이미경, 016-6542-7546
김신제, 010-2415-5444
임수봉, 011-4151-4154
김신애, 011-4151-4444
이다영, 010-4113-2353
박혜진, 010-6331-3939
*/

--@ 시작과 끝 알아야하고, 온전히 시리얼화된(순차적으로 처리,정리된) 데이터만 사용 가능....
--@ 이 두 가지는 굉장히 치명적인 단점임!

--@ 변수형태보다 좀더 큰 레벨일때 이렇게 명명! 커서도 이런 종류
--     타입  이름
CREATE TABLE 테이블명
CREATE USER 유저명
CREATE INDEX 인덱스명
CREATE SEQUENCE 시퀀스명 


--○ 커서 이용 후 상황(다중행 접근 시)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
    
    -- 커서 이용을 위한 커서 변수 선언(→ 커서 정의) CHECK~!!! 
    --@ 커서를 선언한다..보다 커서를 정의한다고 이해하는게 좀더 이해하기 쉬울듯
    /*
    변수명 데이터타입;
    NUM     NUMBER;
    NAME    VARCHAR2(20);
    NAL     DATE;
    */
    CURSOR CUR_INSA_SELECT
    IS --@ 선언이 아니라 정의이기 때문에... 이 커서는 말이지.... 묘사, 서술 이루어져야 함
    SELECT NAME, TEL
    FROM TBL_INSA;
    
BEGIN

    -- 커서 오픈
    --@ 데이터가 왁~! 하고 쏟아져 나옴
    OPEN CUR_INSA_SELECT;
    
    -- 커서 오픈 시 쏟아져나오는 데이터들 처리(잡아내기)
    LOOP
        -- 한 행 한 행 끄집어내어 가져오는 행위 → 『FETCH』
        -- @ 한거번에 끄집어내면 이걸 담을수가 없으니까! 레코드(행) 하나하나씩 패치...
        FETCH CUR_INSA_SELECT INTO V_NAME, V_TEL;
        
        -- 반복문을 빠져나가는 조건은...
        -- 커서로부터 아무것도 찾지 못했을 때...
        --@ 커서가 아무것도 더이상 찾지 못할 때까지! 바닥이 보일때까지!
        EXIT WHEN CUR_INSA_SELECT%NOTFOUND; 
        
        -- 출력
        DBMS_OUTPUT.PUT_LINE(V_NAME||', '||V_TEL);
        
    END LOOP;
    
    -- 커서 클로즈
    CLOSE CUR_INSA_SELECT;

END;
--==>>
/*
홍길동, 011-2356-4528
이순신, 010-4758-6532
이순애, 010-4231-1236
김정훈, 019-5236-4221
한석봉, 018-5211-3542
이기자, 010-3214-5357
장인철, 011-2345-2525
김영년, 016-2222-4444
나윤균, 019-1111-2222
김종서, 011-3214-5555
유관순, 010-8888-4422
정한국, 018-2222-4242
조미숙, 019-6666-4444
황진이, 010-3214-5467
이현숙, 016-2548-3365
이상헌, 010-4526-1234
엄용수, 010-3254-2542
이성길, 018-1333-3333
박문수, 017-4747-4848
유영희, 011-9595-8585
홍길남, 011-9999-7575
이영숙, 017-5214-5282
김인수, 
김말자, 011-5248-7789
우재옥, 010-4563-2587
김숙남, 010-2112-5225
김영길, 019-8523-1478
이남신, 016-1818-4848
김말숙, 016-3535-3636
정정해, 019-6564-6752
지재환, 019-5552-7511
심심해, 016-8888-7474
김미나, 011-2444-4444
이정석, 011-3697-7412
정영희, 
이재영, 011-9999-9999
최석규, 011-7777-7777
손인수, 010-6542-7412
고순정, 010-2587-7895
박세열, 016-4444-7777
문길수, 016-4444-5555
채정희, 011-5125-5511
양미옥, 016-8548-6547
지수환, 011-5555-7548
홍원신, 011-7777-7777
허경운, 017-3333-3333
산마루, 018-0505-0505
이기상, 
이미성, 010-6654-8854
이미인, 011-8585-5252
권영미, 011-5555-7548
권옥경, 010-3644-5577
김싱식, 011-7585-7474
정상호, 016-1919-4242
정한나, 016-2424-4242
전용재, 010-7549-8654
이미경, 016-6542-7546
김신제, 010-2415-5444
임수봉, 011-4151-4154
김신애, 011-4151-4444
이다영, 010-4113-2353
박혜진, 010-6331-3939
*/

--------------------------------------------------------------------------------

--■■■ TRIGGER(트리거) ■■■--

-- 사전적인 의미 : 방아쇠, 촉발시키다. 야기하다. 유발하다.

-- 1. TRIGGER(트리거)란 DML 작업 즉, INSERT, UPDATE, DELETE 작업이 일어날 때
--    자동적으로 실행되는(유발되는, 촉발되는) 객체로
--    이와 같은 특징을 강조하여(부각시켜) DML TRIGGER 라고 부르기도 한다.
--@   DML에 특화되어 사용되기 때문에 그렇게 표현...
--    TRIGGER 는 데이터 무결성 뿐 아니라
--    다음과 같은 작업에도 널리 사용된다.

-- 자동으로 파생된 열 값 생성 -@ 자동으로 어떤 행 입력시켜줌
-- 잘못된 트랜잭션 방지
-- 복잡한 보안 권한 강제 수행
-- 분산 데이터베이스 노드 상에서 참조 무결성 강제 수행
-- 복잡한 업무 규칙 강제 적용
-- 투명한 이벤트 로깅 제공
-- 복잡한 감사 제공
-- 동기 테이블 복제 유지관리
-- 테이블 액세스 통계 수집

-- 2. TRIGGER 내에서는 COMMIT, ROLLBACK 문을 사용할 수 없다.
--@ 나는 인서트만했고 아직 커밋하고 싶지 않은데 강제로 커밋될 수 있으므로....
--@ 큰일남! 트리거에 이거 걸어버리면 안 되므로 사용할 수 없게 만들어 놓음! 

-- 3. 특징 및 종류
--@ 사전, 사후에 수행해야 하는 업무 명확히 되어 있음
--@ 싸움이 일어남......
--@ 맞기 전에 방어행위를 해야 함! 맞고나서 막으면 소용 없음! --> 사전 트리거: BEFROE 트리거
--@ 선생님이 자리 비우심....
--@ 반장에게 떠든 사람들 이름 적으라고 하심. 누가 떠들기 전에 이름 적으면? 안됨! --> 사후 트리거 : AFTER 트리거

--@ BEFORE   STATEMENT(한 문장에만. 한 구문에만 적용)
--@          ROW(전체 행위에 대해 하나하나 봐야 하는 거면)
--@ AFTER   STATEMENT(한 문장에만. 한 구문에만 적용)
--@          ROW(전체 행위에 대해 하나하나 봐야 하는 거면)
--@ 트리거는 크게 총 4가지!


-- BEFORE STATEMENT TRIGGER
-- SQL 구문이 실행되기 전에 그 문장에 대해 한 번 실행

-- BEFORE ROW TRIGGER
-- SQL 구문이 실행되기 전에(DML 작업을 수행하기 전에)
-- 각 행(ROW)에 대해 한 번씩 실행

-- AFTER STATEMENT TRIGGER
-- SQL 구문이 실행된 후 그 문장에 대해 한 번 실행

-- AFTER ROW TRIGGER
-- SQL 구문이 실행된 후에(DML 작업을 수행한 후에)
-- 각 행(ROW)에 대해 한 번씩 실행

-- 4. 형식 및 구조
/*
CREATE [OR REPLACE] TRIGGER 트리거명
    [BEFORE] | [AFTER]
    이벤트1 [OR 이벤트2 [OR 이벤트3]] ON 테이블명
    [FOR EACH ROW [WHEN TRIGGER 조건]]
[DECLARE]
    -- 선언 구문;
BEGIN
    -- 실행 구문;
END;
*/



--■■■ AFTER STATEMENT TRIGGER 상황 실습 ■■■--
--※ DML 작업에 대한 이벤트 기록

--@ 사전처리 X. 조금있으면 INSERT가 일어날거 같아요! 좀있으면 얘가 떠들거같으니까 이름을 미리 적을게요! X
-- TBL_TEST1 / TBL_EVENTLOG

--○ TRIGGER(트리거) 생성(TRG_EVENTLOG)
CREATE OR REPLACE TRIGGER TRG_EVENTLOG
            AFTER 
            INSERT OR UPDATE OR DELETE ON TBL_TEST1   --@ CHECK!
            --@ 기록에 남기는건 EVENTLOG 테이블이지만
            --@ TEST1에 어떤 일이 일어났을때 EVENTLOG에 로그 기록되므로...
            --@ 트리거를 부착해 놓는 건 TEST1 테이블!!!! (주의)
            --@ 트리거 부착 장소 : TBL_TEST1
DECLARE
BEGIN
    -- 이벤트 종류 구분(조건문을 통한 분기)
    IF (INSERTING)   --@ CHECK!
    --@ INSERT 가 일어날 때를 조건으로 구성할 때는 INSERTING!
    --@ INSERT OR UPDATE OR DELETE 중 INSERT가 일어났을 때...
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
             VALUES('INSERT 쿼리문이 수행되었습니다.');
    ELSIF (UPDATING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
             VALUES('UPDATE 쿼리문이 수행되었습니다.');
    ELSIF (DELETING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
             VALUES('DELETE 쿼리문이 수행되었습니다.');
    END IF;
    
    --COMMIT;
    -- ※ TRIGGER 내에서는 COMMIT 구문 사용 불가~!!! CHECK~!!!
    
END;
--==>> Trigger TRG_EVENTLOG이(가) 컴파일되었습니다.


--■■■ BEFORE STATEMENT TRIGGER 에 대한 상황 실습 ■■■--
--@ 맞기 전에 먼저 막는 동작 수행!
--※ DML 작업 수행 전에 작업 가능여부 확인
--   (보안 정책 적용 / 업무 규칙 적용)

--○ TRIGGER(트리거) 작성(TRG_TEST1_DML)
CREATE OR REPLACE TRIGGER TRG_TEST1_DML
           BEFORE
           INSERT OR UPDATE OR DELETE ON TBL_TEST1
DECLARE
BEGIN
    -- 조건 학인 후 작업 가능여부 판단
    IF (시간이 오전 8시 이전이거나... 오후 6시 이후라면...)
        THEN 예외를 발생시키도록 하겠다.
    END IF;
END;


CREATE OR REPLACE TRIGGER TRG_TEST1_DML
           BEFORE
           INSERT OR UPDATE OR DELETE ON TBL_TEST1
-- DECLARE 없다면 생략 가능!
BEGIN
    -- 조건 학인 후 작업 가능여부 판단
    IF ( TO_NUMBER(TO_CHAR(SYSDATE, 'HH24')) < 8 OR TO_NUMBER(TO_CHAR(SYSDATE, 'HH24')) > 17 )
        --@ SYSDATE는 서버쪽에서 돌아가는 거지 유저한테서 돌아가는게 아님!
        --@ 게임 PVP 시간 9시~10시.. 내 핸드폰 시간을 바꾼다고 해서 돌리는게 아님!
        --@ 지금 우리는 각각의 PC에 오라클을 설치... 지금 내컴퓨터에 시간돌리는건 서버/클라이언트 함께 돌리는 것
        
        --@ 주의! 18이 아님. 5시 59분까진 되어야 하니까! 18부터 안 되어야 함
        THEN RAISE_APPLICATION_ERROR(-20003, '작업은 08:00 ~ 18:00까지만 가능합니다.');
    END IF;
END;
--==>> Trigger TRG_TEST1_DML이(가) 컴파일되었습니다.

























